#Ce script permet de déterminer les distributions a posteriori des paramètres
#Il utilise le logciciel stan : http://mc-stan.org/
rm(list=ls())
library(rstan)
setwd("C:/Users/cyrille.pupin/Dropbox/R github/Default")
#Choisir les données :
DMH.data <- readRDS(file="../Data/DMH.rds")
#Chemin vers le fichier contenant les fonctions <<model>>
source("../Stan_model/Model.R")
#Préparation des variables d'entrée
#Calcul des paramètres des priors
M.lambda <- 100       #valeur moyenne de lambda
V.lambda <- 500       #variance de lambda
r.l <- (M.lambda^2)/V.lambda
mu.l <-M.lambda/V.lambda
M.k <- 2
V.k <- 4
r.k <- (M.k^2)/V.k
mu.k <- M.k/V.k
Ess <- as.factor(DMH.data$TypeEss)
input_data <-list(nobs = dim(DMH.data)[1],
nEss = length(levels(Ess)),
Pdmh = DMH.data$Pdmh,
DBH  = DMH.data$DBH,
ess  = as.integer(Ess),
r_l  = r.l,
mu_l = mu.l,
r_k  = r.k,
mu_k = mu.k)
#modèle de Weibull
MCMC_out <- stan(model_code = model_Wkl,
model_name="Wkl_DBH+Ess",
data = input_data,
pars=c("lambda", "k"),
chains=3,
iter = 10000,
warmup=100,
init=rep(list(init_Wkl),
times=3))
#Sauvegarde du fichier brut
saveRDS(MCMC_out, file="../Results/MCMC_Wkl.rds")
#Verification de la convergence
plot(MCMC_out)
print(MCMC_out)
PostDistr <- extract(MCMC_out)
PostDistr$Ess <- levels(Ess)
saveRDS(PostDistr, file="../Results/Post_Wkl.rds")
#modèle de Rayleigh
MCMC_out <- stan(model_code = model_R,
model_name="R_DBH+Ess",
data = input_data,
pars=c("lambda"),
chains=3,
iter = 10000,
warmup=100,
init=rep(list(init_R),
times=3))
#Sauvegarde du fichier brut
saveRDS(MCMC_out, file="../Results/MCMC_R.rds")
#Verification de la convergence
plot(MCMC_out)
print(MCMC_out)
plot(MCMC_out)
PostDistr <- extract(MCMC_out)
PostDistr$k <- rep(2, times=length(PostDistr$lambda))
PostDistr$k <- rep(2, times=dim(PostDistr$lambda)[1])
PostDistr$Ess <- levels(Ess)
saveRDS(PostDistr, file="../Results/Post_R.rds")
#modèle Exponentiel
MCMC_out <- stan(model_code = model_E,
model_name="E_DBH+Ess",
data = input_data,
pars=c("lambda"),
chains=3,
iter = 10000,
warmup=100,
init=rep(list(init_E),
times=3))
#Sauvegarde du fichier brut
saveRDS(MCMC_out, file="../Results/MCMC_E.rds")
#Verification de la convergence
plot(MCMC_out)
print(MCMC_out)
#Extraction des distributions a posteriori
PostDistr <- extract(MCMC_out)
PostDistr$k <- rep(1, times=dim(PostDistr$lambda)[1])
PostDistr$Ess <- levels(Ess)
saveRDS(PostDistr, file="../Results/Post_E.rds")
rm(list=ls())
source("../Scripts/fonctionsMod.R")
Y <- simulation(PostDist.file = "../Results/Post_R.rds")
k <- data.frame(premier=rep(200, 200))
k[1,]
k<-matrix(rep(200, 200))
k[1,]
MCMC_out <- readRDS(file="../Results/MCMC_R.rds")
#Verification de la convergence
plot(MCMC_out)
print(MCMC_out)
#Extraction des distributions a posteriori
PostDistr <- extract(MCMC_out)
PostDistr$k <- matrix(rep(2, times=dim(PostDistr$lambda)[1]))
PostDistr$Ess <- levels(Ess)
#Sauvegarde des distribution a posteriori
saveRDS(PostDistr, file="../Results/Post_R.rds")
MCMC_out <- readRDS(file="../Results/MCMC_E.rds")
#Verification de la convergence
plot(MCMC_out)
print(MCMC_out)
#Extraction des distributions a posteriori
PostDistr <- extract(MCMC_out)
PostDistr$k <- matrix(rep(1, times=dim(PostDistr$lambda)[1]))
PostDistr$Ess <- levels(Ess)
#Sauvegarde des distribution a posteriori
saveRDS(PostDistr, file="../Results/Post_E.rds")
Y <- simulation(PostDist.file = "../Results/Post_R.rds")
PostDist.file = "../Results/Post_R.rds"
out <- readRDS(PostDist.file)
#Ce script permet de déterminer les distributions a posteriori des paramètres
#Il utilise le logiciel stan : http://mc-stan.org/
#Les modèles sont écrit dans un fichier R à part
#Nous prenons en compte ici le modèle de Weibull, le modèle de rayleigh,
#le modèle exponentiel
rm(list=ls())
library(rstan)
setwd("C:/Users/cyrille.pupin/Dropbox/R github/Default")
#Choisir les données :
DMH.data <- readRDS(file="../Data/DMH.rds")
#Chemin vers le fichier contenant les fonctions <<model>>
source("../Stan_model/Model.R")
#Préparation des variables d'entrée
#Calcul des paramètres des priors
M.lambda <- 100       #valeur moyenne de lambda
V.lambda <- 500       #variance de lambda
r.l <- (M.lambda^2)/V.lambda
mu.l <-M.lambda/V.lambda
M.k <- 2
V.k <- 4
r.k <- (M.k^2)/V.k
mu.k <- M.k/V.k
Ess <- as.factor(DMH.data$TypeEss)
input_data <-list(nobs = dim(DMH.data)[1],
nEss = length(levels(Ess)),
Pdmh = DMH.data$Pdmh,
DBH  = DMH.data$DBH,
ess  = as.integer(Ess),
r_l  = r.l,
mu_l = mu.l,
r_k  = r.k,
mu_k = mu.k)
#modèle de Rayleigh
MCMC_out <- stan(model_code = model_R,
model_name="R_DBH+Ess",
data = input_data,
pars=c("lambda"),
chains=3,
iter = 10000,
warmup=100,
init=rep(list(init_R),
times=3))
#Sauvegarde du fichier brut
saveRDS(MCMC_out, file="../Results/MCMC_R.rds")
#Verification de la convergence
plot(MCMC_out)
print(MCMC_out)
#Extraction des distributions a posteriori
PostDistr <- extract(MCMC_out)
PostDistr$k <- matrix(rep(2, times=dim(PostDistr$lambda)[1]))
PostDistr$Ess <- levels(Ess)
#Sauvegarde des distribution a posteriori
saveRDS(PostDistr, file="../Results/Post_R.rds")
rm(list=ls())
source("../Scripts/fonctionsMod.R")
Y <- simulation(PostDist.file = "../Results/Post_R.rds"
)
Z <- simulation(PostDist.file = "../Results/Post_R.rds",
Obs.file = "../Data/DMH.rds",
n.repetitions=10)
X1<- simulation.Dyn(PostDist.file = "../Results/Post_R.rds",
n.repetitions = 10,
Obs.file = "../Data/DMH.rds")
Z <- simulation(PostDist.file = "../Results/Post_R.rds",
Obs.file = "../Data/DMH.rds",
n.repetitions=100)
Z <- simulation(PostDist.file = "../Results/Post_Wkl.rds",
Obs.file = "../Data/DMH.rds",
n.repetitions=100)
saveRDS(Z, file="../Results/Sim_Obs_Wkl.rds")
Z <- simulation(PostDist.file = "../Results/Post_E.rds",
Obs.file = "../Data/DMH.rds",
n.repetitions=100)
saveRDS(Z, file="../Results/Sim_Obs_E.rds")
load("~/Dropbox/R github/Results/Post_E.rds")
T <- load("~/Dropbox/R github/Results/Post_E.rds")
TR <- load("~/Dropbox/R github/Results/Post_E.rds")
install.packages(c("e1071", "FactoMineR", "formatR", "Formula", "labeling", "markdown", "MASS", "mime", "nloptr", "raster", "vcd", "XLConnect"))
library(XLConnect)
demo(plot)
demo()
graphics
demo(graphics)
Z <- simulation(PostDist.file = "../Results/Post_E.rds",
Obs.file = "../Data/DMH.rds",
n.repetitions=100)
saveRDS(Z, file="../Results/Sim_Obs_E.rds")
Z <- simulation(PostDist.file = "../Results/Post_R.rds",
Obs.file = "../Data/DMH.rds",
n.repetitions=100)
saveRDS(Z, file="../Results/Sim_Obs_R.rds")
#modèle Exponentiel
MCMC_out <- stan(model_code = model_E,
model_name="E_DBH+Ess",
data = input_data,
pars=c("lambda"),
chains=3,
iter = 10000,
warmup=100,
init=rep(list(init_E),
times=3))
#Sauvegarde du fichier brut
saveRDS(MCMC_out, file="../Results/MCMC_E.rds")
#Verification de la convergence
plot(MCMC_out)
print(MCMC_out)
#Extraction des distributions a posteriori
PostDistr     <- extract(MCMC_out)
PostDistr$k   <- matrix(rep(1, times=dim(PostDistr$lambda)[1]))
PostDistr$Ess <- levels(Ess)
#Ce script permet de déterminer les distributions a posteriori des paramètres
#Il utilise le logiciel stan : http://mc-stan.org/
#Les modèles sont écrit dans un fichier R à part
#Nous prenons en compte ici le modèle de Weibull, le modèle de rayleigh,
#le modèle exponentiel
rm(list=ls())
library(rstan)
setwd("C:/Users/cyrille.pupin/Dropbox/R github/Default")
#Choisir les données :
DMH.data <- readRDS(file="../Data/DMH.rds")
#Chemin vers le fichier contenant les fonctions <<model>>
source("../Stan_model/Model.R")
#Préparation des variables d'entrée
#Calcul des paramètres des priors
M.lambda <- 100       #valeur moyenne de lambda
V.lambda <- 500       #variance de lambda
r.l <- (M.lambda^2)/V.lambda
mu.l <-M.lambda/V.lambda
M.k <- 2
V.k <- 4
r.k <- (M.k^2)/V.k
mu.k <- M.k/V.k
Ess <- as.factor(DMH.data$TypeEss)
input_data <-list(nobs = dim(DMH.data)[1],
nEss = length(levels(Ess)),
Pdmh = DMH.data$Pdmh,
DBH  = DMH.data$DBH,
ess  = as.integer(Ess),
r_l  = r.l,
mu_l = mu.l,
r_k  = r.k,
mu_k = mu.k)
#modèle Exponentiel
MCMC_out <- stan(model_code = model_E,
model_name="E_DBH+Ess",
data = input_data,
pars=c("lambda"),
chains=3,
iter = 10000,
warmup=100,
init=rep(list(init_E),
times=3))
#Sauvegarde du fichier brut
saveRDS(MCMC_out, file="../Results/MCMC_E.rds")
#Verification de la convergence
plot(MCMC_out)
print(MCMC_out)
#Extraction des distributions a posteriori
PostDistr     <- extract(MCMC_out)
PostDistr$k   <- matrix(rep(1, times=dim(PostDistr$lambda)[1]))
PostDistr$Ess <- levels(Ess)
saveRDS(PostDistr, file="../Results/Post_E.rds")
Z <- simulation(PostDist.file = "../Results/Post_E.rds",
Obs.file = "../Data/DMH.rds",
n.repetitions=100)
saveRDS(Z, file="../Results/Sim_Obs_E.rds")
source("../Scripts/fonctionsMod.R")
Z <- simulation(PostDist.file = "../Results/Post_E.rds",
Obs.file = "../Data/DMH.rds",
n.repetitions=100)
saveRDS(Z, file="../Results/Sim_Obs_E.rds")
#Calcul des critéres de comparaison des modèles
#(Modèle simple VS modèle à plusieurs Var Expl)
#Selon la méthode Predictive Loss (Clark 2007)
#Nous utilisons une méthode basée sur l'individu
##########################################################################
rm(list=ls())
source("../Script/fonctionsMod.R")
#Chargement des données observées
data <- readRDS("../Data/DMH.rds")
Matrice de traitement
Traitement <- matrix(data = c( "Exponentiel", "Rayleigh", "Weibull",
"Post_E.RData",
"Post_R.RData",
"Post_Wkl.RData"),
nrow=3, ncol=2)
VectLettre <- c("E", "R", "Wkl")
RepRes <- "../Results/"
TabF <- list()
indicelist <-1
CritPred <-data.frame(matrix(nrow=3, ncol=0))
#Matrice de traitement
Traitement <- matrix(data = c( "Exponentiel", "Rayleigh", "Weibull",
"Post_E.RData",
"Post_R.RData",
"Post_Wkl.RData"),
nrow=3, ncol=2)
VectLettre <- c("E", "R", "Wkl")
RepRes <- "../Results/"
TabF <- list()
indicelist <-1
CritPred <-data.frame(matrix(nrow=3, ncol=0))
#boucle sur les modèles
for (i in 1:dim(Traitement)[1]){
#choix des données sorties MCMC
SimulObs<-readRDS(file = paste(RepRes,
Prefixe[l],
sub(pattern = ".RData", replacement="_SimObsInd.RData", x=Traitement[i, 2]),
sep=""))
Nom <- Traitement[i, 1]
Results           <- summaryBy( PdmhSim+PdmhObs ~ idArbre, data=SimulObs, FUN = c(mean, var))
Results$Gm        <- (Results$PdmhSim.mean - Results$PdmhObs.mean)^2
#Critère de prédiction
Gm <-   sum(Results$Gm)/length(Results$Gm)
Pm <-   sum(Results$PdmhSim.var)/length(Results$Gm)
Dm <-   Gm + Pm
CritPredTemp  <- c(Gm, Pm, Dm)
CritPred <- cbind(CritPred, CritPredTemp)
}
colnames(CritPred) <-Traitement[, 1]
rownames(CritPred)<-c("Gm", "Pm", "Dm")
Traitement <- matrix(data = c( "Exponentiel", "Rayleigh", "Weibull",
"Sim_Obs_E.RData",
"Sim_Obs_R.RData",
"Sim_Obs_Wkl.RData"),
paste(RepRes,
Traitement[i, 2],
sep="")
=
Traitement <- matrix(data = c( "Exponentiel", "Rayleigh", "Weibull",
"Sim_Obs_E.RData",
"Sim_Obs_R.RData",
"Sim_Obs_Wkl.RData"),
nrow=3, ncol=2)
paste(RepRes,
Traitement[i, 2],
sep="")
SimulObs<-readRDS(file = paste(RepRes,
Traitement[i, 2],
sep=""))
paste(RepRes,
Traitement[i, 2],
sep="")
Traitement <- matrix(data = c( "Exponentiel", "Rayleigh", "Weibull",
"Sim_Obs_E.rds",
"Sim_Obs_R.rds",
"Sim_Obs_Wkl.rds"),
nrow=3, ncol=2)
SimulObs<-readRDS(file = paste(RepRes,
Traitement[i, 2],
sep=""))
#boucle sur les modèles
for (i in 1:dim(Traitement)[1]){
#choix des données sorties MCMC
SimulObs<-readRDS(file = paste(RepRes,
Traitement[i, 2],
sep=""))
Nom <- Traitement[i, 1]
Results           <- summaryBy( PdmhSim+PdmhObs ~ idArbre, data=SimulObs, FUN = c(mean, var))
Results$Gm        <- (Results$PdmhSim.mean - Results$PdmhObs.mean)^2
#Critère de prédiction
Gm <-   sum(Results$Gm)/length(Results$Gm)
Pm <-   sum(Results$PdmhSim.var)/length(Results$Gm)
Dm <-   Gm + Pm
CritPredTemp  <- c(Gm, Pm, Dm)
CritPred <- cbind(CritPred, CritPredTemp)
}
colnames(CritPred) <-Traitement[, 1]
rownames(CritPred)<-c("Gm", "Pm", "Dm")
View(CritPred)
Y <- simulation(PostDist.file = "../Results/Post_Wkl.rds")
saveRDS(Y, file="../Results/Sim_Vect_Wkl.rds")
Y <- simulation(PostDist.file = "../Results/Post_R.rds")
saveRDS(Y, file="../Results/Sim_Vect_R.rds")
Y <- simulation(PostDist.file = "../Results/Post_E.rds")
saveRDS(Y, file="../Results/Sim_Vect_E.rds")
source("../Scripts/fonctionsMod.R")
Y <- simulation(PostDist.file = "../Results/Post_Wkl.rds")
saveRDS(Y, file="../Results/Sim_Vect_Wkl.rds")
Y <- simulation(PostDist.file = "../Results/Post_R.rds")
saveRDS(Y, file="../Results/Sim_Vect_R.rds")
Y <- simulation(PostDist.file = "../Results/Post_E.rds")
saveRDS(Y, file="../Results/Sim_Vect_E.rds")
rm(list=ls())
library(rstan)
setwd("C:/Users/cyrille.pupin/Dropbox/R github/Default")
#Choisir les données :
DMH.data <- readRDS(file="../Data/DMH.rds")
saveRDS(head(DMH.data, file="../Data/DMH_extract.rds"))
#Ce script permet de déterminer les distributions a posteriori des paramètres
#Il utilise le logiciel stan : http://mc-stan.org/
#Les modèles sont écrit dans un fichier R à part
#Nous prenons en compte ici le modèle de Weibull, le modèle de rayleigh,
#le modèle exponentiel
rm(list=ls())
library(rstan)
setwd("C:/Users/cyrille.pupin/Dropbox/R github/Default")
#Choisir les données :
DMH.data <- readRDS(file="../Data/DMH.rds")
saveRDS(head(DMH.data, file="../Data/DMH_extract.rds"))
saveRDS(head(DMH.data), file="../Data/DMH_extract.rds")
